//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;

{{
    nrProps=0
    for mi in Properties 
        nrProps = nrProps+1
    end    

}}
namespace {{NamespaceName}} {

    {{ if nrProps > 0}}
     [GeneratedCode("AOPMethods", "{{version}}")]
    [CompilerGenerated]
    public enum {{ClassName}}_EnumProps{
        None
        {{~ for mi in Properties ~}}
        ,{{mi.Name}} // {{mi.Accesibility}} 
        {{~ end ~}}
    }



    

    {{ end }}

    public class Metadata_{{ClassName}}{

        {{~ for pi in Properties ~}}
        public const string prop_{{pi.Name}} = "{{pi.Name}}";    
        public static readonly System.Linq.Expressions.Expression<Func<{{ClassName}},{{pi.ReturnType}}>> expr_{{pi.Name}} = (it=>it.{{pi.Name}});
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_equal({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}} == value);
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_diff({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}} != value);
        //{{pi.ReturnType}}
        
        {{ if pi.ReturnType  ==  "string" }}   

        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_Ends({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}}.StartsWith (value));
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_Starts({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}}.EndsWith(value));
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_Contains({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}}.Contains(value));    
        {{ end }}
        
        {{ if ((pi.ReturnType  ==  "int?" ) || (pi.ReturnType  ==  "int" ) || (pi.ReturnType  ==  "long")|| (pi.ReturnType  ==  "long?") ) }}   

        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_Greater({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}} > value);
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_GreaterOrEqual({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}} >= value);
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_Less({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}} < value);
        public static System.Linq.Expressions.Expression<Func<{{ClassName}},bool>> expr_{{pi.Name}}_LessOrEqual({{pi.ReturnType}} value)=> (it=>it.{{pi.Name}} <= value);
        {{ end }}
        
        
        {{~ end ~}}
    }

    public interface I{{ClassName}}{
     {{~ for pi in Properties ~}}
         //{{pi.Original.DeclaredAccessibility}} a
         {{pi.ReturnType}} {{pi.Name}} {get;set;}
         
     {{~ end ~}}
    }
    
   
    
    /// <summary>
    /// Generates code from  {{ClassName}}
    /// </summary>
  partial class {{ClassName}} : I{{ClassName}}
  { 
   /*
    public int id(){
    System.Diagnostics.Debugger.Break();
    return 1;
    } 
    */

    {{~ for mi in Properties ~}}
        public const string prop_{{mi.Name}} = "{{mi.Name}}";
    {{~ end ~}}

    partial void OnConstructor();
    partial void AfterCopyConstructor(I{{ClassName}} other);
    public {{ClassName}} (){
            OnConstructor();
        }
     public {{ClassName}}(I{{ClassName}} other):base(){ 

            CopyPropertiesFrom(other:other);
                
        }
        public void CopyPropertiesFrom(I{{ClassName}} other){

            {{~ for mi in Properties ~}}
            this.{{mi.Name}} = other.{{mi.Name}};            
            {{~ end ~}}
            AfterCopyConstructor(other);
        }



    {{~ for mi in Methods ~}}
      {{ 
            separator = "" 
            if(mi.NrParameters > 0)
                separator = "," 
            end
            strAwait = ""
            strAsync =""
            if mi.IsAsync == true
                strAwait = " await "
                strAsync  = " async "
            end
        }}  
        private {{strAsync}} {{mi.ReturnType}} {{mi.NewName}} ({{mi.parametersDefinitionCSharp }}){
            try{
                Console.WriteLine("before calling method {{mi.Name}}");
            {{
                if mi.ReturnsVoid == false
            }}
                return 
            {{
                end
            }}
            {{strAwait}} {{mi.Name}}({{ mi.parametersCallCSharp }});
            }
            catch(Exception ex){
                Console.WriteLine("error in {{mi.Name}}:" + ex.Message);
                throw;
            }
            finally{
                Console.WriteLine("after calling {{mi.Name}}");
            }


        }

      
    {{~ end ~}}
    
  }
}              